(* :Title: Self-affine Tiles *)
(* :Context: FractalGeometry`SelfAffineTiles` *)
(* :Author: Mark McClure *)
(* :Copyright: Copyright 2003, Mark McClure *)
(* :Package Version: 1.0 *)
(* :Mathematica Version: 5.0 *)
(* :Summary: Generates images of self affine tiles. *)

(* :Keywords: tile, fractal, self-affine, 
	self-similar, IFS 
*)

(* :History: Original version written October 2003. *)


(* :Sources: 
	Bandt, C. 1991. "Self-similar sets 5. 
	Integer matrices and fractal tilings of R^n." 
	Proc. Amer. Math. Soc. 112: 549-562.
	
	Darst, R., Palagallo, J., and Price, T. 1998. 
	"Fractal tilings in the plane." Math. Mag. 71(1):12-23.
	
	McClure, M. 2003. "Generating self-affine tiles and
	their boundaries." Preprint.
	
	Strichartz, R. and Wang, Y. 1999. "Geometry of 
	self-affine tiles I." Indiana University Mathematics 
	Journal. 7:1-23.
*)
	

BeginPackage["FractalGeometry`SelfAffineTiles`",
	"FractalGeometry`IFS`",
	"FractalGeometry`DigraphFractals`",
	"FractalGeometry`Common`"
];
Needs["Utilities`FilterOptions`"]
Needs["Graphics`Arrow`"];

SelfAffineTile::usage = "SelfAffineTiles is a package
defining several functions to generate and analyze
self-affine tiles.  For information of self-affine
tiles see http://..."

ShowTile::usage = "ShowTile[A, depth] generates the
self-affine tile defined by the expanding 2 dimensional
integer matrix A to level depth.  The shape of the tile
is also strongly influenced by the choice of the digit
set which may be specified by the option DigitSet."

BaseDigitSet::usage = "BaseDigitSet[A] computes a simple
digit set for the matrix A by choosing the digits to
contained in the parallelogram defined by the column
vectors of A."

ShowBaseDigitSet::usage = "ShowBaseDigitSet[A]
illustrates the base digit set."

StandardDigitSetQ::usage = "StandardDigitSetQ[A, digitSet]
returns True if digitSet is a standard digit set for A and
False if it is not.  A standard digit set is a complete
set of coset representatives for Z^2 / AZ^2."

StretchedTileQ::usage = "StretchedTileQ[A, digitSet] returns
False if the tile corresponding to A and digitSet tiles the 
plane using the lattice Z[digitSet, A.digitSet] and True
otherwise."

TileIFS::usage = "TileIFS[A] sets up the IFS to generate the
self-affine tile defined by A and BaseDigitSet[A].  An
alternate digit set may be defined by the option DigitSet."

BoundaryDigraphIFS::usage = "BoundaryDigraphIFS[A] sets up
the digraph IFS to generate the boundary of the self-affine
tile defined by A and BaseDigitSet[A].  An alternate digi
set may be defined by the option DigitSet."

NonEmptyShifts::usage = "NonEmptyShifts[A] finds the lattice
vectors v with the property that T has non-empty intersection
with T+v, where T is the self-affine tile defined by A."

BoundaryDimension::usage = "BoundaryDimension[A] computes the
dimension of the boundary of the self-affine tile defined
by A."

SubstitutionMatrix::usage = "SubstitutionMatrix[A] computes the
substitution matrix of the tile generated by the matrix A."

StronglyConnectedBoundaryQ::usage = "StronglyConnectedBoundaryQ[A]
determines whether the digraph IFS for the boundary of the tile 
defined by A is strongly connected.  If not, the boundary should 
not be generated stochastically."

ComputeBoundaryPMatrix::usage = "ComputeBoundaryPMatrix[A]
computes a PMatrix which should yield an approximatesly uniform
distribution of points over the boundary when generating the
boundary stochastically."

RandomDigitSet



DigitSet::usage = "DigitSet is an option to ShowTile, TileIFS,
BoundaryDigraphIFS, NonEmptyShifts, and BoundaryDimension
which specifies the digit set to define the self-affine tile."

Basis::usage = "Basis is an option to ShowTile, TileIFS, and
BoundaryDigraphIFS which specifies in which basis A is written."

LatticeGenerators::usage = "LatticeGenerators is an option to
NonEmptyShifts and ShowTileIFS which is occasionally necessary
to coax NonEmptyShifts into working correctly."

Shifts::usage = "Shifts is an option to BoundaryDigraphIFS and
ShowTile which specifies the vectors which should be computed by
NonEmptyShifts.  Specifying Shifts can speed up the computation
and is occassionally necessary to coax BoundaryDigraphIFS to set
up the correct digraph IFS."

Boundary::usage = "Boundary is an option to ShowTile which
specifies whether or not to draw the boundary."

BoundaryAlgorithm::usage = "BoundaryAlgorithm is an option to
ShowTile which specifies which algorithm to use when drawing the
boundary of the tile.  Options are Stochastic or Deterministic.
The default (Stochastic) frequently works better, but does not
always work as the digraph IFS defining the boundary is not
always strongly connected."

Stochastic::usage = "Stochastic is the default setting of
BoundaryAlgorithm."

Deterministic::usage = "Deterministic is one of the possible 
settings of BoundaryAlgorithm."

BoundaryPoints::usage = "BoundaryPoints is an option to
ShowTile which specifies how many points of the boundary to
draw when using the Stocastic algoritm."

BoundaryPMatrix::usage = "BoundaryPMatrix is an option to ShowTile
indicating the PMatrix pass to ShowDigraphFractalsStochastic."

BoundaryDepth::usage = "BoundaryDepth is an option to
ShowTile which specifies to what depth the boundary should be
generated when using the deterministic algorithm."

OutlineParts::usage = "OutlineParts is an option to ShowTile."

ImageTranslates::usage = "ImageTranslates is an option to ShowTile."

(* More Error Messages later *)

SelfAffineTiles::nonStronglyConnected = "The digraph IFS for the
boundary does not appear to be strongly connected.  Results may
be incomplete.  If so, try setting Boundary -> False or
BoundaryAlgorithm -> Deterministic and BoundaryDepth -> anInt."

SelfAffineTiles::stretchedTile = "This self-affine tile appears to
be stretched.  There may be difficulty computing
the non-empty shifts."

SelfAffineTiles::nonStandardDigitSet = "The given digit set is
non-standard.  The resulting set may or may not actually tile."

Begin["`Private`"]

(* Also need to check arguments *)

BaseDigitSet[A_?MatrixQ] := Module[
	{v1, v2, vertices, xMin, xMax, 
	 yMin, yMax, nominations,
	 leftOfLine, leftOfOrOnLine}, 
   
	leftOfLine[{cx_,cy_}, {{ax_,ay_},{bx_,by_}}] := 
		(bx - ax)(cy - ay) - (cx - ax)(by - ay) > 0;
	leftOfOrOnLine[{cx_,cy_}, {{ax_,ay_},{bx_,by_}}] := 
		(bx - ax)(cy - ay) - (cx - ax)(by - ay) >= 0;

	v1 = Transpose[A][[1]]; 
	v2 = Transpose[A][[2]]; 
	If[leftOfLine[v1, {{0,0},v2}],
		{v1,v2} = {v2,v1}];
	vertices = {{0,0}, v1, v2, v1 + v2};
	xMin = Min[Transpose[vertices][[1]]];
	xMax = Max[Transpose[vertices][[1]]];
	yMin = Min[Transpose[vertices][[2]]];
	yMax = Max[Transpose[vertices][[2]]];
	
	nominations = Flatten[Table[{x,y}, 
		{x,xMin,xMax}, {y,yMin,yMax}],1];
	Select[nominations, 
		leftOfOrOnLine[#, {{0,0},v1}] &&
		leftOfLine[#, {v1,v2+v1}] &&
		leftOfLine[#,{v2+v1,v2}] &&
		leftOfOrOnLine[#,{v2,{0,0}}] &
	]
]; 


ShowBaseDigitSet[A_?MatrixQ, opts___] := Module[
	{v1, v2},
	
	v1 = Transpose[A][[1]]; 
	v2 = Transpose[A][[2]]; 
	
	Show[Graphics[{
		{GrayLevel[.6], 
			Polygon[{{0,0}, v1, v1 + v2, v2}]},
		Arrow[{0,0}, v1], 
		Arrow[{0,0}, v2],
		Dashing[{.02}],
		Line[{v1,v1+v2,v2}],
		PointSize[.02],
		Point /@ BaseDigitSet[A]}], opts,
	AspectRatio -> Automatic, Axes -> True]
];


(* A private function *)
(* Called by StandardDigitSetQ *)
CosetRep[A_?MatrixQ, u_] := Module[
	{w, v, wCoeff, vCoeff},

	{w, v} = Transpose[A];
	{wCoeff, vCoeff} = Floor[Inverse[A].u];
	u - wCoeff w - vCoeff v
];


StandardDigitSetQ[A_?MatrixQ, digitSet_] := Length[
	Union[CosetRep[A,#]& /@ digitSet]] == Abs[Det[A]];


(* Doesn't really seem to produce nice things *)
(* Currently private *)
RandomDigitSet[A_] := Module[
	{v1, v2, baseDigitSet, shifts},
	
	{v1,v2} = Transpose[A];	
	baseDigitSet = BaseDigitSet[A];
	shifts = Table[
		Random[Integer, {0,1}](Random[Integer,{-1,1}] v1 + 
			Random[Integer,{-1,1}] v2), {Length[baseDigitSet]}];
	shifts + baseDigitSet
];


StretchedTileQ[A_?MatrixQ, digitSet_] := Module[
	{T, T0, spectralRadius, bound, nominations, 
	 tester, nextT, c, contactMatrix,
	 TSoFar, TSoFarNew, latGen1, latGen2},
	
	{latGen1, latGen2} = LatticeReduce[
		Join[digitSet, A.# &  /@ digitSet]];
	T0 = Flatten[{{latGen1, latGen2},-{latGen1, latGen2}},1];
	spectralRadius[M_] := Max[Abs[Eigenvalues[N[M]]]];
	bound = TileBound[A, digitSet];
	nominations = Complement[Partition[Flatten[
		Table[i latGen1 + j latGen2, 
			{i,-bound,bound},{j,-bound,bound}]],2], 
		{{0,0}}];
	nominations = Complement[Partition[Flatten[
		Table[i latGen1 + j latGen2, 
			{i,-2,2},{j,-2,2}]],2], 
		{{0,0}}];
	tester[k_, T_] := Length[Intersection[A.k + #& /@ digitSet,
		Partition[Flatten[Outer[Plus, T, digitSet, 1]],2]]] > 0;
	nextT[T_] := Select[
		nominations, tester[#, T]&];
	
	T = TSoFar = TSoFarNew = T0;
	While[
		TSoFarNew = Union[TSoFar, T = nextT[T]];
		Length[Complement[TSoFarNew, TSoFar]] > 0,
		TSoFar = TSoFarNew;
	];
	T = TSoFar;
	
	c[k_,l_] := Length@Intersection[A.k + #& /@ digitSet, 
		l + #& /@ digitSet];
	contactMatrix = Outer[c, T, T, 1];
 	spectralRadius[N@contactMatrix] >= Abs[Det[A]]
];


Options[TileIFS] = {
	DigitSet -> Automatic, 
	Basis -> {{1,0},{0,1}}
};
TileIFS[A_?MatrixQ, opts___] := Module[
	{digitSet, basis, B},
	
	digitSet = DigitSet /. {opts} /. Options[TileIFS];
	basis = Basis /. {opts} /. Options[TileIFS];
	B = Transpose[basis];
	
	If[digitSet === Automatic,
		digitSet = BaseDigitSet[A]];
	
	digitSet /. {x_?NumericQ,y_} -> 
		{B.Inverse[A].Inverse[B], B.Inverse[A].{x,y}}
];


(* Private - called by StretchedTileQ and NonEmptyShifts *)
TileBound[A_?MatrixQ, digitSet_] := Module[
	{points, xCoords, yCoords, numPoints,
	 xMin, xMean, xMax, yMin, yMean, yMax,
	 xMinBound, xMaxBound, yMinBound, yMaxBound,
	 ifs, funcs, toFunc, chooser, numFuncs},
	
	numPoints = 200;
	ifs = TileIFS[A, DigitSet -> digitSet];
	numFuncs = Length[ifs];
	toFunc[{matrix_,b_}] := N[matrix.# + b]&;
	funcs = toFunc /@ ifs;
	points = ComposeList[Table[
		chooser = Random[Integer, {1, numFuncs}];
		funcs[[chooser]], 
		{numPoints}], {0,0}];
	
	{xCoords, yCoords} = Transpose[points];
	xMin = Min[xCoords]; xMax = Max[xCoords];
	xMean = (Plus @@ xCoords)/numPoints;
	yMin = Min[yCoords]; yMax = Max[yCoords];
	yMean = (Plus @@ yCoords)/numPoints;
	xMinBound = xMin - 2 (xMean - xMin);
	xMaxBound = xMax + 2 (xMax - xMean);
	yMinBound = yMin - 2 (yMean - yMin);
	yMaxBound = yMax + 2 (yMax - yMean);
	(* {{xMinBound, xMaxBound}, {yMinBound, yMaxBound}} *)
	Ceiling[Max[Abs /@ {xMinBound, xMaxBound,
		yMinBound, yMaxBound}]]
];


Options[NonEmptyShifts] = {
	DigitSet -> Automatic,
	LatticeGenerators -> Automatic
};
NonEmptyShifts[A_?MatrixQ, opts___] := Module[
	{funcs, F, sigma, prune, V1, G1,
	 xGenerator, yGenerator, v, others,
	 (* xMinBound, xMaxBound, yMinBound, yMaxBound, *)
	 bound,
	 digitSet, latticeGenerators},
	
	digitSet = DigitSet /. {opts} /. Options[NonEmptyShifts];
	If[digitSet === Automatic,
		digitSet = BaseDigitSet[A]];
	
	latticeGenerators = LatticeGenerators /. {opts} /. 
		Options[NonEmptyShifts];
	If[latticeGenerators === Automatic,
		If[!StretchedTileQ[A, digitSet],
			latticeGenerators = LatticeReduce[Join[
				digitSet, A.# &  /@ digitSet]],
			Message[SelfAffineTiles::stretchedTile];
			latticeGenerators = LatticeReduce[digitSet];
		]
	];
	funcs[l1_,l2_] := 
		Module[{f}, (#/.( h[x_,y_] :> (f[x]= y)) /. 
			func[___] :> f)] & /@
			Flatten[Outer[func, Sequence @@ Outer[h,l1,l2,1]]];	
	sigma /: Subscript[F_List, sigma[f_]] :=
		F /. {x_?NumericQ,y_} :> (A.{x,y} + 
			f[{x,y}] - f[{0,0}]);
	prune[G_,V_] := Module[{newG,newV},
		newG = Select[G /. node[v_, others_] :> 
			node[v,Intersection[others,V]], Length[#[[2]]] > 0&];
		newV = First /@ newG;
		{newG,newV}];
	prune[{G_,V_}] := prune[G,V];
	
	bound = TileBound[A, digitSet];
	V1 = Select[Flatten[Table[{{0,0}, 
		i latticeGenerators[[1]] + j latticeGenerators[[2]]}, 
		{i,-bound, bound}, {j,-bound, bound}],1],
			# != {{0,0},{0,0}}&];
	G1 = (node @@@ V1 /. node[l1__] :> node[{l1},
		Subscript[{l1},#]& /@ (sigma /@ funcs[{l1}, digitSet])]);
	Last /@ FixedPoint[prune, {G1, V1}][[2]]
];


Options[BoundaryDigraphIFS] = {
	DigitSet -> Automatic, 
	LatticeGenerators -> Automatic,
	Shifts -> Automatic,
	Basis -> {{1,0},{0,1}}
};
BoundaryDigraphIFS[A_?MatrixQ, opts___] := Module[
	{digitSet, basis, a, b, pairs, M, h, B,
	 digitPairsMatrix, latticeGenerators, shifts},
	
	digitSet = DigitSet /. {opts} /. Options[BoundaryDigraphIFS];
	basis = Basis /. {opts} /. Options[BoundaryDigraphIFS];
	latticeGenerators = LatticeGenerators /. {opts} /. 
		Options[BoundaryDigraphIFS];
	shifts = Shifts /. {opts} /. Options[BoundaryDigraphIFS];
	If[digitSet === Automatic,
		digitSet = BaseDigitSet[A]];
	If[shifts === Automatic, 
		shifts = NonEmptyShifts[A, opts]];
	B = Transpose[basis];
	
	pairs[l_List] := (Flatten[Outer[h,l,l,1]] /. h :> List);
	M[a_,b_] := Select[pairs[digitSet],
		#[[1]] - #[[2]] == b - A.a &];
	digitPairsMatrix = Outer[M, shifts, shifts, 1];
	digitPairsMatrix /.{_, {x_?NumericQ,y_}} -> 
		{B.Inverse[A].Inverse[B], B.Inverse[A].{x,y}}
];


Options[SubstitutionMatrix] = {
	DigitSet -> Automatic,
	LatticeGenerators -> Automatic,
	Shifts -> Automatic
};
SubstitutionMatrix[A_?MatrixQ, opts___] := Module[
	{},
	
	Map[Length, BoundaryDigraphIFS[A, opts], {2}]
];


StronglyConnectedBoundaryQ[A_, opts___] := Module[
	{subsMatrix, k},
	
	subsMatrix = SubstitutionMatrix[A, opts];
	Length[Cases[Sum[MatrixPower[subsMatrix, k],
        {k, 1, Length[subsMatrix]}], 0, {2}]] == 0
];


Options[ShowTile] = Join[{
	Boundary -> True,
	BoundaryAlgorithm -> Stochastic,
	BoundaryPoints -> 10000,
	BoundaryPMatrix -> Automatic,
	BoundaryDepth -> 4,
	LatticeGenerators -> Automatic,
	Shifts -> Automatic,
	Color -> True,
	Colors -> Automatic,
	DigitSet -> Automatic,
	Basis -> {{1,0},{0,1}},
	OutlineParts -> True,
	ImageTranslates -> None}, Options[Graphics]
];
ShowTile[A_?MatrixQ, depth_Integer, opts___] := Module[
	{boundary, boundaryPoints, boundaryDepth, boundaryAlgorithm,
	 tileIFS, tilePic, points, boundaries, pic, outlineParts,
	 imageTranslates, B, shifts, digitSet},
	
	boundary = Boundary /. {opts} /. Options[ShowTile];
	boundaryPoints = BoundaryPoints /. {opts} /. Options[ShowTile];
	boundaryDepth = BoundaryDepth /. {opts} /. Options[ShowTile];
	boundaryAlgorithm = BoundaryAlgorithm /. {opts} /. Options[ShowTile];
	outlineParts = OutlineParts /. {opts} /. Options[ShowTile];
	imageTranslates = ImageTranslates /. {opts} /. Options[ShowTile];
	B = Transpose[Basis] /. {opts} /. Options[ShowTile];
	shifts = Shifts /. {opts} /. Options[ShowTile];
	digitSet = DigitSet /. {opts} /. Options[ShowTile];
	
	If[digitSet =!= Automatic,
		If[StandardDigitSetQ[A, digitSet] === False,
			Message[SelfAffineTiles::nonStandardDigitSet]
		]
	];
	
	tileIFS = TileIFS[A, 
		FilterOptions[TileIFS, opts]];
	If[boundary === True,
		If[Shifts === Automatic,
			shifts = NonEmptyShifts[A,
				FilterOptions[NonEmptyShifts, opts]]
		];
		boundaryIFS = BoundaryDigraphIFS[A, Shifts -> shifts,
			FilterOptions[BoundaryDigraphIFS, opts]];
		If[boundaryAlgorithm === Stochastic,
			If[!StronglyConnectedDigraphQ[boundaryIFS],
				Message[SelfAffineTiles::nonStronglyConnected]
			];
			boundaryPic = ShowDigraphFractalsStochastic[
				boundaryIFS, boundaryPoints,
				DisplayFunction -> Identity,
				FilterOptions[ShowDigraphFractalsStocastic, opts],
				PMatrix -> ComputeBoundaryPMatrix[A,opts]
			],
			boundaryPic = ShowDigraphFractals[
				boundaryIFS, boundaryDepth,
				DisplayFunction -> Identity,
				FilterOptions[ShowDigraphFractalsStocastic, opts]
			]
		];
		If[outlineParts === True,
			points = Cases[boundaryPic, _Point, Infinity];
			boundaries = ShowIFS[tileIFS,1,
				Initiator -> points,
				DisplayFunction -> Identity],
			boundaries = boundaryPic
		],
		boundaries = Graphics[{}]
	];
	tilePic = ShowIFS[tileIFS, depth,
		DisplayFunction -> Identity,
		FilterOptions[ShowIFS, opts], Color -> True];
	If[imageTranslates === None,
		pic = {tilePic, boundaries},
		pic = {tilePic, boundaries} /. Point[p_] :> 
			Point[p+B.#]& /@ imageTranslates
	];
	
	Show[pic,
		{FilterOptions[Graphics, opts],
		 DisplayFunction -> $DisplayFunction}]
];


(* Need to check if A is conjugate to a similarity *)
Options[BoundaryDimension] = {
	DigitSet -> Automatic,
	Shifts -> Automatic
};
BoundaryDimension[A_?MatrixQ, opts___] := Module[
	{digitSet, a, b, pairs, M, h, spectralRadius,
	 digitPairsMatrix, F, digitPairer},

	spectralRadius[M_] := Max[Abs[Eigenvalues[N[M]]]];	
	digitSet = DigitSet /. {opts} /. Options[BoundaryDigraphIFS];
	If[digitSet === Automatic,
		digitSet = BaseDigitSet[A]
	];
	shifts = Shifts /. {opts} /. Options[BoundaryDigraphIFS];
	If[shifts === Automatic,
		F = NonEmptyShifts[A, opts],
		F = shifts
	];
	
	pairs[l_List] := (Flatten[Outer[h,l,l,1]] /. h :> List);
	digitPairer[a_,b_] := Select[pairs[digitSet],
		#[[1]] - #[[2]] == b - A.a &];
	digitPairsMatrix = Outer[digitPairer, F, F, 1];
	M = Map[Length, digitPairsMatrix, {2}];
	Log[spectralRadius[M]]/Log[spectralRadius[A]]
];

Options[BoundaryPMatrix] = {
	DigitSet -> Automatic, 
	Shifts -> Automatic
}; 
ComputeBoundaryPMatrix[A_, opts___] := Module[
	{digitSet, subsMatrix, pMatrixNormalizer, r, 
	dimMatrix, perronNumbers, pMatrix1, pMatrix2,
	spectralRadius}, 
	
	spectralRadius[M_]:=Max[Abs[Eigenvalues[N[M]]]];
	subsMatrix = SubstitutionMatrix[A, opts];
	pMatrixNormalizer[subPList_List] := If[Length[subPList] > 0, 
		subPList/Plus @@ subPList, subPList]; 
	r = 1/spectralRadius[subsMatrix]; 
	dimMatrix = Transpose[subsMatrix] /. n_Integer :> Sum[r, {n}]; 
	perronNumbers = Eigensystem[dimMatrix][[2]][[1]]; 
	pMatrix1 = Inner[Times, dimMatrix, perronNumbers, List]/perronNumbers; 
	pMatrix2 = Transpose[subsMatrix] /. n_Integer :> Table[r, {n}]; 
	pMatrix2 = Map[pMatrixNormalizer, pMatrix2, {2}]; 
	Transpose[pMatrix1 pMatrix2]
];

End[]  (* End Private Context *)

(* Still need Protect[] *)

EndPackage[]
